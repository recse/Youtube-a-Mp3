{"ast":null,"code":"import PropTypes from'prop-types';import chainPropTypes from'./chainPropTypes';function isClassComponent(elementType){// elementType.prototype?.isReactComponent\nvar _elementType$prototyp=elementType.prototype,prototype=_elementType$prototyp===void 0?{}:_elementType$prototyp;return Boolean(prototype.isReactComponent);}function acceptingRef(props,propName,componentName,location,propFullName){var element=props[propName];var safePropName=propFullName||propName;if(element==null){return null;}var warningHint;var elementType=element.type;/**\n   * Blacklisting instead of whitelisting\n   *\n   * Blacklisting will miss some components, such as React.Fragment. Those will at least\n   * trigger a warning in React.\n   * We can't whitelist because there is no safe way to detect React.forwardRef\n   * or class components. \"Safe\" means there's no public API.\n   *\n   */if(typeof elementType==='function'&&!isClassComponent(elementType)){warningHint='Did you accidentally use a plain function component for an element instead?';}if(warningHint!==undefined){return new Error(\"Invalid \".concat(location,\" `\").concat(safePropName,\"` supplied to `\").concat(componentName,\"`. \")+\"Expected an element that can hold a ref. \".concat(warningHint,\" \")+'For more information see https://material-ui.com/r/caveat-with-refs-guide');}return null;}var elementAcceptingRef=chainPropTypes(PropTypes.element,acceptingRef);elementAcceptingRef.isRequired=chainPropTypes(PropTypes.element.isRequired,acceptingRef);export default elementAcceptingRef;","map":{"version":3,"sources":["C:/Users/recse/Desktop/PORTFOLIOS/descargador/cliente/src/node_modules/@material-ui/utils/esm/elementAcceptingRef.js"],"names":["PropTypes","chainPropTypes","isClassComponent","elementType","_elementType$prototyp","prototype","Boolean","isReactComponent","acceptingRef","props","propName","componentName","location","propFullName","element","safePropName","warningHint","type","undefined","Error","concat","elementAcceptingRef","isRequired"],"mappings":"AAAA,MAAOA,CAAAA,SAAP,KAAsB,YAAtB,CACA,MAAOC,CAAAA,cAAP,KAA2B,kBAA3B,CAEA,QAASC,CAAAA,gBAAT,CAA0BC,WAA1B,CAAuC,CACrC;AACA,GAAIC,CAAAA,qBAAqB,CAAGD,WAAW,CAACE,SAAxC,CACIA,SAAS,CAAGD,qBAAqB,GAAK,IAAK,EAA/B,CAAmC,EAAnC,CAAwCA,qBADxD,CAEA,MAAOE,CAAAA,OAAO,CAACD,SAAS,CAACE,gBAAX,CAAd,CACD,CAED,QAASC,CAAAA,YAAT,CAAsBC,KAAtB,CAA6BC,QAA7B,CAAuCC,aAAvC,CAAsDC,QAAtD,CAAgEC,YAAhE,CAA8E,CAC5E,GAAIC,CAAAA,OAAO,CAAGL,KAAK,CAACC,QAAD,CAAnB,CACA,GAAIK,CAAAA,YAAY,CAAGF,YAAY,EAAIH,QAAnC,CAEA,GAAII,OAAO,EAAI,IAAf,CAAqB,CACnB,MAAO,KAAP,CACD,CAED,GAAIE,CAAAA,WAAJ,CACA,GAAIb,CAAAA,WAAW,CAAGW,OAAO,CAACG,IAA1B,CACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAEE,GAAI,MAAOd,CAAAA,WAAP,GAAuB,UAAvB,EAAqC,CAACD,gBAAgB,CAACC,WAAD,CAA1D,CAAyE,CACvEa,WAAW,CAAG,6EAAd,CACD,CAED,GAAIA,WAAW,GAAKE,SAApB,CAA+B,CAC7B,MAAO,IAAIC,CAAAA,KAAJ,CAAU,WAAWC,MAAX,CAAkBR,QAAlB,CAA4B,IAA5B,EAAkCQ,MAAlC,CAAyCL,YAAzC,CAAuD,iBAAvD,EAA0EK,MAA1E,CAAiFT,aAAjF,CAAgG,KAAhG,EAAyG,4CAA4CS,MAA5C,CAAmDJ,WAAnD,CAAgE,GAAhE,CAAzG,CAAgL,2EAA1L,CAAP,CACD,CAED,MAAO,KAAP,CACD,CAED,GAAIK,CAAAA,mBAAmB,CAAGpB,cAAc,CAACD,SAAS,CAACc,OAAX,CAAoBN,YAApB,CAAxC,CACAa,mBAAmB,CAACC,UAApB,CAAiCrB,cAAc,CAACD,SAAS,CAACc,OAAV,CAAkBQ,UAAnB,CAA+Bd,YAA/B,CAA/C,CACA,cAAea,CAAAA,mBAAf","sourcesContent":["import PropTypes from 'prop-types';\nimport chainPropTypes from './chainPropTypes';\n\nfunction isClassComponent(elementType) {\n  // elementType.prototype?.isReactComponent\n  var _elementType$prototyp = elementType.prototype,\n      prototype = _elementType$prototyp === void 0 ? {} : _elementType$prototyp;\n  return Boolean(prototype.isReactComponent);\n}\n\nfunction acceptingRef(props, propName, componentName, location, propFullName) {\n  var element = props[propName];\n  var safePropName = propFullName || propName;\n\n  if (element == null) {\n    return null;\n  }\n\n  var warningHint;\n  var elementType = element.type;\n  /**\n   * Blacklisting instead of whitelisting\n   *\n   * Blacklisting will miss some components, such as React.Fragment. Those will at least\n   * trigger a warning in React.\n   * We can't whitelist because there is no safe way to detect React.forwardRef\n   * or class components. \"Safe\" means there's no public API.\n   *\n   */\n\n  if (typeof elementType === 'function' && !isClassComponent(elementType)) {\n    warningHint = 'Did you accidentally use a plain function component for an element instead?';\n  }\n\n  if (warningHint !== undefined) {\n    return new Error(\"Invalid \".concat(location, \" `\").concat(safePropName, \"` supplied to `\").concat(componentName, \"`. \") + \"Expected an element that can hold a ref. \".concat(warningHint, \" \") + 'For more information see https://material-ui.com/r/caveat-with-refs-guide');\n  }\n\n  return null;\n}\n\nvar elementAcceptingRef = chainPropTypes(PropTypes.element, acceptingRef);\nelementAcceptingRef.isRequired = chainPropTypes(PropTypes.element.isRequired, acceptingRef);\nexport default elementAcceptingRef;"]},"metadata":{},"sourceType":"module"}