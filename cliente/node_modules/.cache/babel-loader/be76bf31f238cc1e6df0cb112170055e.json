{"ast":null,"code":"import _extends from'@babel/runtime/helpers/esm/extends';import warning from'tiny-warning';var separatorRegExp=/\\s*,\\s*/g;var parentRegExp=/&/g;var refRegExp=/\\$([\\w-]+)/g;/**\n * Convert nested rules to separate, remove them from original styles.\n *\n * @param {Rule} rule\n * @api public\n */function jssNested(){// Get a function to be used for $ref replacement.\nfunction getReplaceRef(container,sheet){return function(match,key){var rule=container.getRule(key)||sheet&&sheet.getRule(key);if(rule){rule=rule;return rule.selector;}process.env.NODE_ENV!==\"production\"?warning(false,\"[JSS] Could not find the referenced rule \\\"\"+key+\"\\\" in \\\"\"+(container.options.meta||container.toString())+\"\\\".\"):void 0;return key;};}function replaceParentRefs(nestedProp,parentProp){var parentSelectors=parentProp.split(separatorRegExp);var nestedSelectors=nestedProp.split(separatorRegExp);var result='';for(var i=0;i<parentSelectors.length;i++){var parent=parentSelectors[i];for(var j=0;j<nestedSelectors.length;j++){var nested=nestedSelectors[j];if(result)result+=', ';// Replace all & by the parent or prefix & with the parent.\nresult+=nested.indexOf('&')!==-1?nested.replace(parentRegExp,parent):parent+\" \"+nested;}}return result;}function getOptions(rule,container,prevOptions){// Options has been already created, now we only increase index.\nif(prevOptions)return _extends({},prevOptions,{index:prevOptions.index+1// $FlowFixMe[prop-missing]\n});var nestingLevel=rule.options.nestingLevel;nestingLevel=nestingLevel===undefined?1:nestingLevel+1;var options=_extends({},rule.options,{nestingLevel:nestingLevel,index:container.indexOf(rule)+1// We don't need the parent name to be set options for chlid.\n});delete options.name;return options;}function onProcessStyle(style,rule,sheet){if(rule.type!=='style')return style;var styleRule=rule;var container=styleRule.options.parent;var options;var replaceRef;for(var prop in style){var isNested=prop.indexOf('&')!==-1;var isNestedConditional=prop[0]==='@';if(!isNested&&!isNestedConditional)continue;options=getOptions(styleRule,container,options);if(isNested){var selector=replaceParentRefs(prop,styleRule.selector);// Lazily create the ref replacer function just once for\n// all nested rules within the sheet.\nif(!replaceRef)replaceRef=getReplaceRef(container,sheet);// Replace all $refs.\nselector=selector.replace(refRegExp,replaceRef);container.addRule(selector,style[prop],_extends({},options,{selector:selector}));}else if(isNestedConditional){// Place conditional right after the parent rule to ensure right ordering.\ncontainer.addRule(prop,{},options)// Flow expects more options but they aren't required\n// And flow doesn't know this will always be a StyleRule which has the addRule method\n// $FlowFixMe[incompatible-use]\n// $FlowFixMe[prop-missing]\n.addRule(styleRule.key,style[prop],{selector:styleRule.selector});}delete style[prop];}return style;}return{onProcessStyle:onProcessStyle};}export default jssNested;","map":{"version":3,"sources":["C:/Users/recse/Desktop/PORTFOLIOS/descargador/cliente/src/node_modules/jss-plugin-nested/dist/jss-plugin-nested.esm.js"],"names":["_extends","warning","separatorRegExp","parentRegExp","refRegExp","jssNested","getReplaceRef","container","sheet","match","key","rule","getRule","selector","process","env","NODE_ENV","options","meta","toString","replaceParentRefs","nestedProp","parentProp","parentSelectors","split","nestedSelectors","result","i","length","parent","j","nested","indexOf","replace","getOptions","prevOptions","index","nestingLevel","undefined","name","onProcessStyle","style","type","styleRule","replaceRef","prop","isNested","isNestedConditional","addRule"],"mappings":"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","sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport warning from 'tiny-warning';\n\nvar separatorRegExp = /\\s*,\\s*/g;\nvar parentRegExp = /&/g;\nvar refRegExp = /\\$([\\w-]+)/g;\n/**\n * Convert nested rules to separate, remove them from original styles.\n *\n * @param {Rule} rule\n * @api public\n */\n\nfunction jssNested() {\n  // Get a function to be used for $ref replacement.\n  function getReplaceRef(container, sheet) {\n    return function (match, key) {\n      var rule = container.getRule(key) || sheet && sheet.getRule(key);\n\n      if (rule) {\n        rule = rule;\n        return rule.selector;\n      }\n\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"[JSS] Could not find the referenced rule \\\"\" + key + \"\\\" in \\\"\" + (container.options.meta || container.toString()) + \"\\\".\") : void 0;\n      return key;\n    };\n  }\n\n  function replaceParentRefs(nestedProp, parentProp) {\n    var parentSelectors = parentProp.split(separatorRegExp);\n    var nestedSelectors = nestedProp.split(separatorRegExp);\n    var result = '';\n\n    for (var i = 0; i < parentSelectors.length; i++) {\n      var parent = parentSelectors[i];\n\n      for (var j = 0; j < nestedSelectors.length; j++) {\n        var nested = nestedSelectors[j];\n        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.\n\n        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + \" \" + nested;\n      }\n    }\n\n    return result;\n  }\n\n  function getOptions(rule, container, prevOptions) {\n    // Options has been already created, now we only increase index.\n    if (prevOptions) return _extends({}, prevOptions, {\n      index: prevOptions.index + 1 // $FlowFixMe[prop-missing]\n\n    });\n    var nestingLevel = rule.options.nestingLevel;\n    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;\n\n    var options = _extends({}, rule.options, {\n      nestingLevel: nestingLevel,\n      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.\n\n    });\n\n    delete options.name;\n    return options;\n  }\n\n  function onProcessStyle(style, rule, sheet) {\n    if (rule.type !== 'style') return style;\n    var styleRule = rule;\n    var container = styleRule.options.parent;\n    var options;\n    var replaceRef;\n\n    for (var prop in style) {\n      var isNested = prop.indexOf('&') !== -1;\n      var isNestedConditional = prop[0] === '@';\n      if (!isNested && !isNestedConditional) continue;\n      options = getOptions(styleRule, container, options);\n\n      if (isNested) {\n        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for\n        // all nested rules within the sheet.\n\n        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.\n\n        selector = selector.replace(refRegExp, replaceRef);\n        container.addRule(selector, style[prop], _extends({}, options, {\n          selector: selector\n        }));\n      } else if (isNestedConditional) {\n        // Place conditional right after the parent rule to ensure right ordering.\n        container.addRule(prop, {}, options) // Flow expects more options but they aren't required\n        // And flow doesn't know this will always be a StyleRule which has the addRule method\n        // $FlowFixMe[incompatible-use]\n        // $FlowFixMe[prop-missing]\n        .addRule(styleRule.key, style[prop], {\n          selector: styleRule.selector\n        });\n      }\n\n      delete style[prop];\n    }\n\n    return style;\n  }\n\n  return {\n    onProcessStyle: onProcessStyle\n  };\n}\n\nexport default jssNested;\n"]},"metadata":{},"sourceType":"module"}